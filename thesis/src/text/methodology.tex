\section{Microservices are not the silver bullet}
Over the last decade, microservices architecture has become so popular that very few people question whether it is the right architecture for the project at hand, and whether there might be something better for the job. One reason for this may be the incredible flood of articles on the web, with primers focusing on the positive aspects of microservices and how they can solve (almost) every problem, while not talking much about the possible negative aspects. It is important to note that most of the articles and success stories actually come from large companies with enormous resources (e.g. Netflix, Amazon, Coca-Cola) that none of the small/medium companies can match, while these smaller companies also face completely different challenges than the multinationals.

Microservices are very closely related to the modern concept of cloud computing, which has become a multi-billion market (\$545 billion in 2022\cite{CC_MARKET_SIZE}) with the potential to bring huge savings, but also huge expenses if not used properly. And let's not pretend that these cloud service providers are not, of course, trying to convince us to convert our infrastructure and systems to new modern technologies in order to increase their profits. This is nothing new, as everyone is just trying to make money, but we should be aware of their intentions when they try to convince us to use their technologies - which in the case of microservices and their complexity of operation and deployment will inevitably force us to use their services, but with monoliths we are usually capable of running everything ourselves.

To present some concrete data, let's look at some real-world examples where microservices were not considered to be the right solution.

\begin{example}[Amazon Prime]
    An example where microservices proved to be too costly a choice, and the entire application had to be migrated to a monolithic architecture for the system to be efficient, comes from Amazon. On 22 March (2023), Amazon's video streaming service called Prime Video published an article on their technology blog with the headline "Scaling the Prime Video audio/video monitoring service and reducing costs by 90\%". Prime Video offers thousands of live streams to its customers. To ensure that customers receive content seamlessly, Prime Video set up a tool to monitor every stream that customers watched to identify any perceived quality issues. \cite{AMAZON_ARTICLE}

    The initial version of the service consisted of distributed components orchestrated by \textit{AWS Step Functions}. This would allow each component to scale independently. However, the way they used the components meant that they hit a hard scaling limit at around 5\,\% of the expected load. Also, the total cost of all the components was too high to use on a large scale. The two most costly operations were the orchestration workflow and passing data between distributed components. To address this, they moved all the components into a single process to keep the data transfer within the process memory, which also simplified the orchestration logic. With all operations now consolidated into a single process, they were able to rely on scalable Amazon compute (EC2) and container (ECS) instances for deployment. \cite{AMAZON_ARTICLE}

    Conceptually, the high-level architecture remains the same. They still have exactly the same components as in the original design (media conversion, detectors, orchestration). This allowed them to reuse a lot of code and migrate quickly. Originally, they could scale multiple detectors horizontally because each one ran as a separate microservice. However, in the new approach, the number of detectors could only scale vertically, as they all ran within the same instance, and this would quickly exceed the capacity of a single instance. This limitation was overcome by running multiple instances and implementing a lightweight orchestration layer to distribute customer requests. Overall, the migration from a distributed microservices architecture to a monolithic one enabled them to reduce infrastructure costs by over 90\,\% and increase scalability. \cite{AMAZON_ARTICLE}
\end{example}

\begin{example}[Shopify]
    An example of a company that still successfully operates a monolithic system with thousands of developers is Shopify. It is a complete commerce platform that allows businesses to build an online store, market to customers and accept payments. The article\cite{SHOPIFY_MONOLITH_ARTICLE} with the most insight into their architecture is from 16 Sep 2020, and they regularly write more insight stories about their Monolith on their \textit{Shopify Engineering}\cite{SHOPIFY_ENGINEERING} website.

    They have a massive monolith written in the Ruby on Rails framework, its core alone has over 2.8 million lines of Ruby code. This is one of the oldest and largest Rails codebases on the planet and has been in continuous development since at least 2006. Rails doesn't provide patterns or tools for managing the inherent complexity and adding features in a structured, well-bounded way. That's why, in 2017, Shopify set up a team to investigate how to make its Rails monoliths more modular. The aim was to make it easier for them to scale to ever-increasing system capabilities and complexity by creating smaller, independent units of code, which they called components. The added constraints on how they wrote code triggered deep software design discussions across the organisation. This led to a shift in the mindset of developers towards a greater focus on modular design. Clearly defined ownership of parts of the code base was a key factor in the successful transition. \cite{SHOPIFY_MONOLITH_ARTICLE}

    The initial focus was on building a clean public interface around each component to hide the internals. The expectation was that changing the internals of one component wouldn't break other components, and it would be easier to understand the behaviour of a component in isolation. They had to balance the encapsulation with the dependency graph to avoid circular dependencies, which are very risky because changing any component in the chain can break all the other components. Various techniques such as control inversion and publish/subscribe mechanisms were introduced to help minimise relationships and reduce coupling. In the end they ended up with 37 components in the main monolith, and they are very deliberate about splitting functionality into separate services due to the overall complexity of a distributed system of services. \cite{SHOPIFY_MONOLITH_ARTICLE}
\end{example}

\begin{note*}
    Netflix is one of the most cited companies for its microservices architecture. What is not so well known is that the actual migration from monolithic system, when they started to have problems with performance and scaling, was in 2009. At that point they had been using Monolith for 10 years and had over 11~million \cite{NETFLIX_2009_EARNINGS} paying subscribers by that time. No one knows what would happen if they started the original architecture with something else, maybe it would work, but definitely the Monolith worked well until it just didn't fit their needs anymore.
\end{note*}

\section{Decision making}
Every software project consists of at least 6 phases: planning, design, development, testing, deployment and maintenance. We will mainly be discussing the first two: planning and design, because this is where the high-level decision about the architecture is made. Ideally, a software architect creates the concepts and designs for software and helps to turn those concepts into plans, just as an architect designs buildings. In smaller projects, the role of software architect will usually fall to the most experienced developer. While building architects are not usually concerned with how their ideas are implemented, a software architect is involved in all stages of the development process, not just the architecture, but any high-level decisions about the tools, coding standards or platforms to be used.

The architecture of the system is probably the most important decision to be made, as it influences all subsequent stages of development and is usually quite difficult to change afterwards. Interestingly, the choice of architecture is not just about meeting all the requirements of the project, but it must also fit the style of the organisation. There is an IT theory created by computer scientist/programmer Melvin Conway in 1967 which states: ``Organisations that design systems are forced to produce designs that are copies of the communication structures of those organisations.''\cite{paper:conway:1968}. And that theory makes a lot of sense. When we have to make a difficult decision, we are always more likely to choose something we know well rather than something that might be better but with which we have no experience. Also, not all designs might be compatible with our organisational structure. For example, a monolith with a 4-month release cycle won't work for an early-stage startup where they're adding new features to their product every week and working in short iteration cycles. The same is true vice versa. Having a microservices architecture, fast iteration cycles and the ability to deploy whenever a feature is ready is great, but when applied in an organisation with a complex hierarchical structure, where simple changes take weeks to get approved, it does not even remotely exploit the benefits the architecture has to offer.

The importance of choosing the right architecture for many software projects is underestimated and influenced by new shiny trends and fancy words in the IT industry instead of being driven primarily by requirements, which can lead to unstable, inefficient and overpriced projects.

\subsection{Choosing right criteria}
To ensure that the chosen software architecture meets the needs of the software to be developed, it is very important that the architect fully grasps and understands the business needs that will be served. These should be understood as much as the technical and functional expectations of the application. The general aspects to consider:
\begin{itemize}
    \item Security and performance requirements
    \item Client and vendor expectations
    \item The type of hosting
    \item Technologies
\end{itemize}

To produce good requirements, you need to answer as many questions as possible. It is essential that all requirements are as specific and concrete as possible. Having vague and unachievable requirements is almost as good as having none at all. It's not enough to say performance, portability or scalability. No project can have perfect performance. It must be properly specified, and also limited so that other requirements can be met as well\cite{REQUIREMENTS_LIMITED}.
% TODO přidat diagram x dimenzí a že nelze každou mít na 100, ale je třeba kompromisů - fancy diagram nevím jak se jim žíká

Requirements generally fall into two categories:
\begin{itemize}
    \item \textbf{Functional requirements} describe what a system must do. If the system does not meet the functional requirements, it will fail. This is because it is unable to do something it needs to do to work properly. Another way of looking at functional requirements is in terms of inputs and outputs: they specify what the system must do in response to different inputs, and what it must output.
    \item \textbf{Non-functional requirements} describe how the system works. They focus on how the system delivers the specified functionality. At first glance they may seem less important than functional requirements, but they are both important. Non-functional requirements do not affect the functionality of the system, but they do affect how well it performs.
\end{itemize}

Another thing that can influence the decision is the experience of the team. If we have a team of developers with a lot of experience in building monoliths and no experience with distributed systems, choosing microservice architecture as a starting point may turn out to be a decision we will regret. Microservices require a completely different mindset to the one the team was used to when building monoliths. And we could easily end up with \textit{Distributed Monolith} that should be avoided at all costs.

\section{Building a new application}
If you are building an application from the ground up, I strongly believe the Modulith is currently the best choice for majority of projects. See Table~\ref{table:architecture_compare} with architecture summary in the first chapter, based on which the Modulith has the best qualities from both architectures Monolith and Microservices. Hybrid Modulith being slightly more close to Microservices through ability to scale individual modules. After all, why does everyone choose microservices in the first place? Because of performance? At the start of the project, we have some assumptions about the performance requirements, but they are still just "assumptions" and the actual performance issues are in most cases caused by the limitations of the actual implementation. In previous chapter, section~\ref{section:benchmark_results}, by benchmarking example implementation I have proven Modulith architecture to be superior in terms of performance, and Hybrid Modulith being superior in terms of scalability and resource usage (see Table~\ref{table:benchmark_modulith_instances}). Also, the performance requirements can change dramatically if the business goes in a different direction than expected at the beginning and Modulith is more flexible to changes.

So, the reason could be the independence of microservices? The Modulith offers the same quality with modules. Only the microservices are more dramatically enforcing smaller scope, which can be leveraged for modules in the same way. What about testability? Again, modules can be tested in the same independent way as microservices, and even further using techniques known from monoliths such as end-to-end testing, without all the shenanigans associated with microservices and orchestrations. Maintainability? Modulith has a much simpler deployment strategy, less complex environment and is cheaper to host. Sustainability? The amount of work required to just merge two microservices into one or change API of single service is very high, since you can't even effectively find all the dependants and update them all accordingly. On the other hand, since Modulith is just a single codebase, the relationships are there and visible just by using standard and proven tools, e.g. IDE with `find usage' feature. Also, any deep refactoring can be done in Modulith in a much easier way than in Microservice. The biggest negative aspect for small/medium projects lies in the ability of developers to properly define the scope and boundary of modules and more importantly to maintain it over time, as the individual microservices have a network boundary which is hard to cross, but with Modulith it is much easier as it is a single repository with inter-process communication, but this can be largely avoided by setting up automated tools which will enforce the boundaries at code level directly by monitoring cross-module dependencies.

% vývojáři musí správně nastavit scope a boundaries, složitější uhlídat, musí se správně nastavit ?procesy?
The recommended approach for building new application:
\begin{enumerate}
    \item \textbf{Modularization} Take the whole business domain and start divinding it into smaller parts until you reach single business responsibility per part. For each part properly define the scope and boundaries. Modeling around business domain has proven for Microservices to be the best approach\cite{BUILDING_MS_WHAT_ARE}, and it can easily be applied for Moduliths as well. This step usually impossible to get right the first time, so it is a more iterative process.
    \item Create module for each defined part and expose its functionality over interface.
    \item Module can use other modules functionality via defined interface.
    \item Build the Modulith application
    \item Prepare application to scale as a unit (see Figure~\ref{fig:scale_as_unit}) - running in multiple instances is usually required for high availability and better performance.
    \item If performance is an issue, utilize Hybrid Modulith architecture. This should be implemented with caution, as it may not even be needed as long as the scalability achieved by the previous step is sufficient, since it introduces significant negative effects:
          \begin{itemize}
              \item Becomes a distributed system - network instability, higher latency, complexity, complicated debugging and logging.
              \item More complicated deployment - some form of versioning is required to ensure compatibility between individual modules.
              \item More code and tools - instead of just having interfaces and implementing them in separate modules, now they also need to be implemented to support network calls, so some client/server code needs to be implemented or ideally generated by additional tools.
          \end{itemize}

          If you are sure to continue, follow the steps:
          \begin{enumerate}
              \item Identify the module that is causing the performance problem
              \item Move the module into a separate service, along with all its dependent modules, to eliminate network calls as much as possible, effectively creating two Moduliths with a network communication between them (Hybrid Modulith, see Figure~\ref{fig:hybrid_modulith}).
              \item Scale both Moduliths independently according to load
              \item Repeat the division into more Moduliths until sufficient performance is achieved. Note that using this step to the extreme may convert the architecture to microservices, which may be better suited in that case, see section~\ref{subsection:modulith_to_microservices} for more details.
          \end{enumerate}
          % \item *Optional* Identify modules having performance issues and move them into independent service (another Modulith).
          % \item Scale the independent Moduliths as required.
          % \item In case of need for additional granularity migrate to Microservices architecture.
    \item Enforce module boundaries during whole application lifecycle and adapt them as business needs change.
\end{enumerate}


\section{Modulith lifecycle}
The ability of an architecture to adapt to different requirements over time is an important quality. Modulith is situated between Monolith and Microservices, which gives it the ability to easily convert back and forth between different architectural styles. The following text describes some examples of how Modulith can be used.

% Monolith -> Modulith, mnohem snažší a iterativní oproti Monolith -> Microservice
\subsection{Monolith to Modulith}
\label{subsection:monolith_to_modulith}
Many software companies that have been around for a few years and did not jump into the microservices hype right away have some legacy monolithic systems that are costly to maintain, but they cannot be converted to microservices because it would require rewriting the whole system from scratch, and no one in the company wants to make that kind of big investment that would basically not bring any new functionality.

Instead of this radical approach of rewriting the whole system, which will basically cost the company twice the money, because rewriting the system means creating a new project with all the steps of development: analysis, design, etc. and long period of bug fixing. I would rather suggest an iterative approach of transforming the existing monolith into a modulith by concentrating on solving the specific problem at hand, rather than trying to solve everything at once by rewriting the application. The method is shown on figure~\ref{fig:monolith_to_modulith_steps} and consists of the following steps:

\begin{enumerate}
    \item \textbf{Modularization} step imposes the restructuring of the code and the modularisation of the whole application, but without worrying about the problems associated with a distributed system (network reliability, latency, complexity). Proper focus can be invested in defining modules, their responsibilities and boundaries. Depending on the project, the scope of modules can vary from complex modules to individual responsibilities per module.
    \item \textbf{Scale unit} step is to prepare the application to scale by running multiple instances. Monolithic systems are usually stateful or require some form of synchronisation for some of their functionality. In this step, all these potential or actual barriers to running multiple instances need to be resolved or replaced with solutions that can scale. Now the application can achieve high availability and increased performance by scaling the entire instance. The architecture has now reached the definition of modularity.
    \item \textbf{Scale modules} step takes scalability even further by allowing individual modules or groups of modules to be scaled, rather than the whole application as a unit. By completing the step, the architecture reaches the state defined in this thesis as \textit{Hybrid Modulith}.
\end{enumerate}

\begin{figure}
    \centering
    \begin{subfigure}{.5\textwidth}
        \centering
        \includesvg[width=0.5\textwidth]{images/monolith_to_modulith_0.svg}
        \caption{Original Monolith}
    \end{subfigure}%
    \begin{subfigure}{.5\textwidth}
        \centering
        \includesvg[width=0.7\textwidth]{images/monolith_to_modulith_1.svg}
        \caption{Modularization step}
    \end{subfigure}
    % \vspace{0.5cm}
    \begin{subfigure}{\textwidth}
        \centering
        \includesvg[width=0.4\textwidth]{images/monolith_to_modulith_2.svg}
        \caption{Scale unit step (reached Modulith)\label{fig:scale_as_unit}}
    \end{subfigure}%
    \hfill
    \begin{subfigure}{\textwidth}
        \centering
        \includesvg[width=0.7\textwidth]{images/monolith_to_modulith_3.svg}
        \caption{Scale modules step (reached Hybrid Modulith \label{fig:hybrid_modulith})}
    \end{subfigure}
    \caption{Conversion steps from Monolith to Hybrid Modulith}
    \label{fig:monolith_to_modulith_steps}
\end{figure}

% Modulith scaling, přidávání instancí a rozdělení Modulithu (lze dělit na různě velké celky)

% Modulith -> Microservice, multiple teams, want to add network boundaries and more granular responsibility distribution
\subsection{Modulith to Microservice}
\label{subsection:modulith_to_microservices}
Over time, the modular architecture may no longer meet the needs of the project. Examples of reasons: more fine-grained granularity of the application is required, teams need more independence, lack of technology agnosticism, or a more distributed solution is desired to achieve higher availability or scalability.

After properly weighing all the pros and cons, a decision can be made to migrate to a microservice architecture. The transformation should ideally take place in natural steps over time as requirements and system needs change. Modulith consists of individually scalable modules with defined boundaries. Moving to a microservice architecture is about refining these modules and transforming them into microservices by defining fine-grained boundaries. In cases where modules have been defined with small scopes, the transformation can be as simple as 1 module to 1 microservice, but we might have originally set bigger boundaries, which do not comply with Microservices ideology usually driven by the principle of single business responsibility. So, before doing the migration, the modules needs to be broken down into smaller modules, which than can be mapped directly to individual microservices. The transformation step from Modulith to Microservices is shown in figure~\ref{fig:modulith_to_microservices_steps}.

\begin{figure}
    \centering
    \includesvg[width=\textwidth]{images/modulith_to_microservices_steps.svg}
    \caption{Conversion step from Modulith to Microservices.\label{fig:modulith_to_microservices_steps}}
\end{figure}


% Microservice -> Modulith, sloučení služeb sníží overhead, zjednodušší vývoj, vhodně pro menší týmy
\subsection{Microservice to Modulith}
% pozn. různé technologie/jazyky
Microservices architecture can become too complex to manage or simply too expensive to operate. An example of the former is described in detail in chapter~\ref{chapter:personal_experience}. The solution can be to convert microservices to Modulith, which simplifies deployment, resulting in cheaper infrastructure, and increases developer productivity by removing the complexity of a distributed system.

The migration is easily done by converting microservices to modules as shown in Figure~\ref{fig:microservices_to_modulith_steps}, as they are already fully encapsulated and have a defined API. Network communication can be completely replaced by inter-process communication, or if some modules require scalability for performance, they can be converted to \textit{Hybrid Modulith} as specified in the \textit{Scale Modules} step of section~\ref{subsection:monolith_to_modulith}. Later, some modules may merge to take on more responsibility, but this depends on how module boundaries are set within the project.

\begin{figure}
    \centering
    \includesvg[width=\textwidth]{images/microservices_to_modulith_steps.svg}
    \caption{Conversion step from Microservices to Modulith.\label{fig:microservices_to_modulith_steps}}
\end{figure}



% TODO: At the start of planning phase, all criteria which will drive the decision should be specified, so they can be later used to transparently compare different solutions and choose the best of them. 

% Overlooked importance of choosing right architecture, leads to instability, insifficency and hight costs
% to undestood, architect must fully grasps business needs 
% - describe architect and his role in software design 
% - quote M. Conway, a computer scientist, once said: “Organizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations.” This is a clear guideline for architects to take into account the company structure when designing new solutions. 

% záleží i na týmu - každý má jiné zkušenosti a znalosti -> bude trvat než se adaptují
% Choosing criteria - list
% functional and non-functional requirements

% be awera of over-engineering
% Prototype, iterations - fail fast

% Sources https://www.bocasay.com/web-application-software-architecture/
% https://dl.acm.org/doi/epdf/10.1145/1978802.1978812 (první article na decision making)
% - Hence architects should choose a decision-making technique based on the difficulties that they wish to avoid. (začátek)
% - Software architecture determines not only how the system should be constructed, but also guides its evolution
% https://www.lucidchart.com/blog/how-to-design-software-architecture
% - It’s not enough to say you want performance, portability, or scalability, though. Non-functional requirements must also be quantified. No project can have absolutely perfect performance: “performance” must be specified and limited in order to meet other requirements. 


% Přidat několik praktických příkladů s úvodem, různými architekturami a možnými následky