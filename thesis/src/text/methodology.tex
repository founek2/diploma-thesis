
If you are building an application from scratch, or just looking for a flexible architecture, I strongly believe that the Modulith is currently the best choice for the majority of projects. Based on the architecture summary from the first chapter Table~\ref{table:architecture_compare}, the Modulith shares the best qualities of both monolithic and microservices architectures. My experience from financial projects in chapter~\ref{chapter:personal_experience} argues against microservices as an unnecessarily complex architecture and the benchmarks in chapter~\ref{chapter:example_application} confirm the superior performance of Modulith and the same ability to scale with the hybrid Modulith approach. Based on all the work and results, I have created a methodology that can be used as a guide for architecture decisions when starting a new project:

\begin{enumerate}
    \item \textbf{Modularization} - take the whole business domain and start dividing it into smaller parts until you reach single business responsibility per part. For each part properly define the scope and boundaries. Modeling around business domain has proven for Microservices to be the best approach\cite{BUILDING_MS_WHAT_ARE}, and it can easily be applied for Moduliths as well. This step usually impossible to get right the first time, so it is a more iterative process.
    \item Create module for each defined part from previous step and expose its functionality over interface.
    \item Module can use other modules' functionality via defined interface.
    \item Build the Modulith application.
    \item Prepare application to scale as a unit (see Figure~\ref{fig:scale_as_unit}) - running in multiple instances is usually required for high availability and better performance.
    \item If deployment is slow or process too complex, you can deploy modules individually (more about deployment at bottom of section~\ref{section:modulith}).
    \item If performance is an issue, utilize Hybrid Modulith architecture. This should be implemented with caution, as it may not even be needed as long as the scalability achieved by the previous step is sufficient. See section~\ref{subsection:modulith_to_hybrid_modulith} for more details.
        
          % \item *Optional* Identify modules having performance issues and move them into independent service (another Modulith).
          % \item Scale the independent Moduliths as required.
          % \item In case of need for additional granularity migrate to Microservices architecture.
    \item Enforce module boundaries during whole application lifecycle and adapt them as business needs change.
    \item If needed, Modulith can be easily converted into Microservices, see section~\ref{subsection:modulith_to_microservices}.
    \begin{itemize}
        \item Once the need for Microservices subside, it can be easily converted back to Modulith, see section~\ref{subsection:microservices_to_modulith}
    \end{itemize}
\end{enumerate}

\begin{note}
    For additional arguments in favour of Modulith over Microservices, please refer to Section~\ref{section:building_new_app}.
\end{note}

% \section{Decision making}
% Every software project consists of at least 6 phases: planning, design, development, testing, deployment and maintenance. We will mainly be discussing the first two: planning and design, because this is where the high-level decision about the architecture is made. Ideally, a software architect creates the concepts and designs for software and helps to turn those concepts into plans, just as an architect designs buildings. In smaller projects, the role of software architect will usually fall to the most experienced developer. While building architects are not usually concerned with how their ideas are implemented, a software architect is involved in all stages of the development process, not just the architecture, but any high-level decisions about the tools, coding standards or platforms to be used.

% The architecture of the system is probably the most important decision to be made, as it influences all subsequent stages of development and is usually quite difficult to change afterwards. Interestingly, the choice of architecture is not just about meeting all the requirements of the project, but it must also fit the style of the organisation. There is an IT theory created by computer scientist/programmer Melvin Conway in 1967 which states: ``Organisations that design systems are forced to produce designs that are copies of the communication structures of those organisations.''\cite{paper:conway:1968}. And that theory makes a lot of sense. When we have to make a difficult decision, we are always more likely to choose something we know well rather than something that might be better but with which we have no experience. Also, not all designs might be compatible with our organisational structure. For example, a monolith with a 4-month release cycle won't work for an early-stage startup where they're adding new features to their product every week and working in short iteration cycles. The same is true vice versa. Having a microservices architecture, fast iteration cycles and the ability to deploy whenever a feature is ready is great, but when applied in an organisation with a complex hierarchical structure, where simple changes take weeks to get approved, it does not even remotely exploit the benefits the architecture has to offer.

% The importance of choosing the right architecture for many software projects is underestimated and influenced by new shiny trends and fancy words in the IT industry instead of being driven primarily by requirements, which can lead to unstable, inefficient and overpriced projects.

% \subsection{Choosing right criteria}
% To ensure that the chosen software architecture meets the needs of the software to be developed, it is very important that the architect fully grasps and understands the business needs that will be served. These should be understood as much as the technical and functional expectations of the application. The general aspects to consider:
% \begin{itemize}
%     \item Security and performance requirements
%     \item Client and vendor expectations
%     \item The type of hosting
%     \item Technologies
% \end{itemize}

% To produce good requirements, you need to answer as many questions as possible. It is essential that all requirements are as specific and concrete as possible. Having vague and unachievable requirements is almost as good as having none at all. It's not enough to say performance, portability or scalability. No project can have perfect performance. It must be properly specified, and also limited so that other requirements can be met as well\cite{REQUIREMENTS_LIMITED}.
% % TODO přidat diagram x dimenzí a že nelze každou mít na 100, ale je třeba kompromisů - fancy diagram nevím jak se jim žíká

% Requirements generally fall into two categories:
% \begin{itemize}
%     \item \textbf{Functional requirements} describe what a system must do. If the system does not meet the functional requirements, it will fail. This is because it is unable to do something it needs to do to work properly. Another way of looking at functional requirements is in terms of inputs and outputs: they specify what the system must do in response to different inputs, and what it must output.
%     \item \textbf{Non-functional requirements} describe how the system works. They focus on how the system delivers the specified functionality. At first glance they may seem less important than functional requirements, but they are both important. Non-functional requirements do not affect the functionality of the system, but they do affect how well it performs.
% \end{itemize}

% Another thing that can influence the decision is the experience of the team. If we have a team of developers with a lot of experience in building monoliths and no experience with distributed systems, choosing microservice architecture as a starting point may turn out to be a decision we will regret. Microservices require a completely different mindset to the one the team was used to when building monoliths. And we could easily end up with \textit{Distributed Monolith} that should be avoided at all costs.

\section{Why Modulith over Microservices}
\label{section:building_new_app}
If you are building an application from the ground up, I strongly believe the Modulith is currently the best choice for majority of projects. See Table~\ref{table:architecture_compare} with architecture summary in the first chapter, based on which the Modulith has the best qualities from both architectures Monolith and Microservices. 

After all, why does everyone choose microservices in the first place? Because of performance? At the start of the project, we have some assumptions about the performance requirements, but they are still just "assumptions" and the actual performance issues are in most cases caused by the limitations of the actual implementation. In previous chapter, section~\ref{section:benchmark_results}, by benchmarking example implementation I have proven Modulith architecture to be superior in terms of performance, and Hybrid Modulith being superior in terms of scalability and resource usage (see Table~\ref{table:benchmark_modulith_instances}). Also, the performance requirements can change dramatically if the business goes in a different direction than expected at the beginning and Modulith is more flexible to changes.

So, the reason could be the independence of microservices? The Modulith offers the same quality with modules. Only the microservices are more dramatically enforcing smaller scope, which can be leveraged for modules in the same way. What about testability? Again, modules can be tested in the same independent way as microservices, and even further using techniques known from monoliths such as end-to-end testing, without all the shenanigans associated with microservices and orchestrations. Maintainability? Modulith has a much simpler deployment strategy, less complex environment and is cheaper to host. Sustainability? The amount of work required to just merge two microservices into one or change API of single service is very high, since you can't even effectively find all the dependants and update them all accordingly. On the other hand, since Modulith is just a single codebase, the relationships are there and visible just by using standard and proven tools, e.g. IDE with `find usage' feature. Also, any deep refactoring can be done in Modulith in a much easier way than in Microservice. The biggest negative aspect for small/medium projects lies in the ability of developers to properly define the scope and boundary of modules and more importantly to maintain it over time, as the individual microservices have a network boundary which is hard to cross, but with Modulith it is much easier as it is a single repository with inter-process communication, but this can be largely avoided by setting up automated tools which will enforce the boundaries at code level directly by monitoring cross-module dependencies.

% vývojáři musí správně nastavit scope a boundaries, složitější uhlídat, musí se správně nastavit ?procesy?
% The recommended approach for building new application:



% \section{Modulith lifecycle}
% The ability of an architecture to adapt to different requirements over time is an important quality. Modulith is situated between Monolith and Microservices, which gives it the ability to easily convert back and forth between different architectural styles. The following text describes some examples of how Modulith can be used.

% Monolith -> Modulith, mnohem snažší a iterativní oproti Monolith -> Microservice
\section{Monolith to Modulith}
\label{subsection:monolith_to_modulith}
Many software companies that have been around for a few years and did not jump into the microservices hype right away have some legacy monolithic systems that are costly to maintain, but they cannot be converted to microservices because it would require rewriting the whole system from scratch, and no one in the company wants to make that kind of big investment that would basically not bring any new functionality.

Instead of this radical approach of rewriting the whole system, which will basically cost the company twice the money, because rewriting the system means creating a new project with all the steps of development: analysis, design, etc. and long period of bug fixing. I would rather suggest an iterative approach of transforming the existing monolith into a modulith by concentrating on solving the specific problem at hand, rather than trying to solve everything at once by rewriting the application. The method is shown on Figure~\ref{fig:monolith_to_modulith_steps} and consists of the following steps:

\begin{enumerate}
    \item \textbf{Modularization} step imposes the restructuring of the code and the modularisation of the whole application, but without worrying about the problems associated with a distributed system (network reliability, latency, complexity). Proper focus can be invested in defining modules, their responsibilities and boundaries. Depending on the project, the scope of modules can vary from complex modules to individual responsibilities per module.
    \item \textbf{Scale unit} step is to prepare the application to scale by running multiple instances. Monolithic systems are usually stateful or require some form of synchronisation for some of their functionality. In this step, all these potential or actual barriers to running multiple instances need to be resolved or replaced with solutions that can scale. Now the application can achieve high availability and increased performance by scaling the entire instance. The architecture has now reached the definition of modularity.
    \item \textbf{Scale modules} step takes scalability even further by allowing individual modules or groups of modules to be scaled, rather than the whole application as a unit. By completing the step, the architecture reaches the state defined in this thesis as \textit{Hybrid Modulith}. See~\ref{subsection:modulith_to_hybrid_modulith} for more details.
\end{enumerate}

\begin{figure}
    \centering
    \begin{subfigure}{.5\textwidth}
        \centering
        \includesvg[width=0.5\textwidth]{images/monolith_to_modulith_0.svg}
        \caption{Original Monolith}
    \end{subfigure}%
    \begin{subfigure}{.5\textwidth}
        \centering
        \includesvg[width=0.7\textwidth]{images/monolith_to_modulith_1.svg}
        \caption{Modularization step}
    \end{subfigure}
    % \vspace{0.5cm}
    \begin{subfigure}{\textwidth}
        \centering
        \includesvg[width=0.4\textwidth]{images/monolith_to_modulith_2.svg}
        \caption{Scale unit step (reached Modulith)\label{fig:scale_as_unit}}
    \end{subfigure}%
    \hfill
    \begin{subfigure}{\textwidth}
        \centering
        \includesvg[width=0.7\textwidth]{images/monolith_to_modulith_3.svg}
        \caption{Scale modules step (reached Hybrid Modulith \label{fig:hybrid_modulith})}
    \end{subfigure}
    \caption{Conversion steps from Monolith to Hybrid Modulith}
    \label{fig:monolith_to_modulith_steps}
\end{figure}

\section{Modulith to Hybrid Modulith}
\label{subsection:modulith_to_hybrid_modulith}
When scaling as a single unit is no longer sufficient, the Modulith can be converted to a Hybrid Modulith, which allows scaling with more granular control. Be very cautions about using this approach since it introduces significant negative effects:
\begin{itemize}
    \item Application becomes a distributed system - network instability, higher latency, complexity, complicated debugging and logging.
    \item More complicated deployment - some form of versioning is required to ensure compatibility between individual modules.
    \item More code and tools - instead of just having interfaces and implementing them in separate modules, now they also need to be implemented to support network calls, so some client/server code needs to be implemented or ideally generated by additional tools.
\end{itemize}

If you are sure to continue, follow the steps:
\begin{enumerate}
    \item Identify the module that is causing the performance problem
    \item Move the module into a separate service, along with all its dependent modules, to eliminate network calls as much as possible, effectively creating two Moduliths with a network communication between them (Hybrid Modulith, see Figure~\ref{fig:hybrid_modulith}).
    \item Scale both Moduliths independently according to load
    \item Repeat the division into more Moduliths until sufficient performance is achieved. Note that using this step to the extreme may convert the architecture to microservices, which may be better suited in that case, see subsection~\ref{subsection:modulith_to_microservices} for more details.
\end{enumerate}

% Modulith scaling, přidávání instancí a rozdělení Modulithu (lze dělit na různě velké celky)

% Modulith -> Microservice, multiple teams, want to add network boundaries and more granular responsibility distribution
\section{Modulith to Microservice}
\label{subsection:modulith_to_microservices}
Over time, the modular architecture may no longer meet the needs of the project. Examples of reasons: more fine-grained granularity of the application is required, teams need more independence, lack of technology agnosticism, or a more distributed solution is desired to achieve higher availability or scalability.

After properly weighing all the pros and cons, a decision can be made to migrate to a microservice architecture. The transformation should ideally take place in natural steps over time as requirements and system needs change. Modulith consists of individually scalable modules with defined boundaries. Moving to a microservice architecture is about refining these modules and transforming them into microservices by defining fine-grained boundaries. In cases where modules have been defined with small scopes, the transformation can be as simple as 1 module to 1 microservice, but we might have originally set bigger boundaries, which do not comply with Microservices ideology usually driven by the principle of single business responsibility. So, before doing the migration, the modules needs to be broken down into smaller modules, which than can be mapped directly to individual microservices. The transformation step from Modulith to Microservices is shown in Figure~\ref{fig:modulith_to_microservices_steps}.

\begin{figure}
    \centering
    \includesvg[width=\textwidth]{images/modulith_to_microservices_steps.svg}
    \caption{Conversion step from Modulith to Microservices.\label{fig:modulith_to_microservices_steps}}
\end{figure}


% Microservice -> Modulith, sloučení služeb sníží overhead, zjednodušší vývoj, vhodně pro menší týmy
\section{Microservice to Modulith}
\label{subsection:microservices_to_modulith}
% pozn. různé technologie/jazyky
Microservices architecture can become too complex to manage or simply too expensive to operate. An example of the former is described in detail in chapter~\ref{chapter:personal_experience}. The solution can be to convert microservices to Modulith, which simplifies deployment, resulting in cheaper infrastructure, and increases developer productivity by removing the complexity of a distributed system.

The migration is easily done by converting microservices to modules as shown in Figure~\ref{fig:microservices_to_modulith_steps}, as they are already fully encapsulated and have a defined API. Network communication can be completely replaced by inter-process communication, or if some modules require scalability for performance, they can be converted to \textit{Hybrid Modulith} as specified in the \textit{Scale Modules} step of section~\ref{subsection:monolith_to_modulith}. Later, some modules may merge to take on more responsibility, but this depends on how module boundaries are set within the project.

\begin{figure}
    \centering
    \includesvg[width=\textwidth]{images/microservices_to_modulith_steps.svg}
    \caption{Conversion step from Microservices to Modulith.\label{fig:microservices_to_modulith_steps}}
\end{figure}

% \clearpage
\section{Summary}
The modular architecture methodology has been created as a step-by-step guide for new projects based on Modulith architecture. It defines how the business domain should be divided to modularise the application, how it should communicate internally to keep coupling low, and how it should evolve over time to increase performance and scalability. Each architecture step is detailed and illustrated with diagrams. The flexibility of Modulith even allows for a smooth transition back and forth between microservices and the said architecture.

% TODO: At the start of planning phase, all criteria which will drive the decision should be specified, so they can be later used to transparently compare different solutions and choose the best of them. 

% Overlooked importance of choosing right architecture, leads to instability, insifficency and hight costs
% to undestood, architect must fully grasps business needs 
% - describe architect and his role in software design 
% - quote M. Conway, a computer scientist, once said: “Organizations which design systems ... are constrained to produce designs which are copies of the communication structures of these organizations.” This is a clear guideline for architects to take into account the company structure when designing new solutions. 

% záleží i na týmu - každý má jiné zkušenosti a znalosti -> bude trvat než se adaptují
% Choosing criteria - list
% functional and non-functional requirements

% be awera of over-engineering
% Prototype, iterations - fail fast

% Sources https://www.bocasay.com/web-application-software-architecture/
% https://dl.acm.org/doi/epdf/10.1145/1978802.1978812 (první article na decision making)
% - Hence architects should choose a decision-making technique based on the difficulties that they wish to avoid. (začátek)
% - Software architecture determines not only how the system should be constructed, but also guides its evolution
% https://www.lucidchart.com/blog/how-to-design-software-architecture
% - It’s not enough to say you want performance, portability, or scalability, though. Non-functional requirements must also be quantified. No project can have absolutely perfect performance: “performance” must be specified and limited in order to meet other requirements. 


% Přidat několik praktických příkladů s úvodem, různými architekturami a možnými následky