% Do not forget to include Introduction
%---------------------------------------------------------------
% \chapter{Introduction}
% uncomment the following line to create an unnumbered chapter
% \chapter*{Introduction}\addcontentsline{toc}{chapter}{Introduction}\markboth{Introduction}{Introduction}
%---------------------------------------------------------------

\chapter*{Introduction}
\setcounter{page}{1}

Software architecture is the foundation of every application. Like foundation is construction, it has profound effect on the quality of what is build on top of it. As such, it holds a great importance in terms of the successful development and maintenance of the whole system. Architecture serves as a blueprint for a system. It provides an abstraction to manage the system complexity and establish a communication and coordination mechanism among components. Since the dawn of software development, the Monolith architecture has been the industry's favored solution.  However, the increasing complexity of applications has brought to light its limitations in terms of scalability, modularity and maintenance. Since then, there has been a search for a new type of architecture that will overcome these limitations.

Several approaches have been tried, such as Service Oriented Architecture, which seemed promising, but none have matched the popularity of the Monolith. However, more than ten years ago, the Microservices architecture emerged and has spread extensively across the industry, becoming the new standard. Microservices shine at solving the most pressing problem which has risen with constantly increasing number of application consumers, the scalability by allowing to scale horizontally individual parts of the system on demand. The entire application is split into small components with limited responsibility called ``microservice'', which further improves maintenance and makes the system easier to understand.

Unfortunately, Microservices constitute a type of distributed system that introduces significant complexity to the application and complicates deployment. They undoubtedly offer great benefits for sizeable projects with many development teams, yet smaller and medium-sized projects frequently overlook alternative options like Modular architecture. It falls midway between Monolith and Microservices, combining the effortless deployment of Monolith and modularity of Microservices without the complexity of distributed system. The scalability can be achieved later as well by utilizing hybrid approaches.

The objective of this thesis is to elucidate the frequently overlooked disadvantages of Microservices and recommend modern modular alternatives. This is imperative as Microservices can significantly increase project expenses, impede development progress and even result in project failure in the worst-case scenario. The first chapter of the thesis is devoted to a detailed analysis of the Monolith, Modular and Microservices architectures, culminating in a comparative analysis in relation to several factors such as communication, maintenance, deployment and complexity. In the second chapter, an example application is created for each type of architecture and comprehensively analyzed concerning performance and latency. The third chapter presents the authors' personal experience after working over a year on a project utilizing Microservices architecture established four years prior, as well as from personal project that was initially converted to Microservices and then to Modular architecture. The thesis concludes with the creation of a methodology for selecting the appropriate architecture for a new project and how it can be applied and further modified over the course of the application's lifecycle.

% vymezení rozsahu - primárně malé až střední projekty, web-based architecture (not Performance apps)



% The following environment can be used as a mini-introduction for a chapter. Use that any way it pleases you (or comment it out). It can contain, for instance, a summary of the chapter. Or, there can be a quotation.
% \begin{chapterabstract}
%     \lipsum[1]
% \end{chapterabstract}

% \lipsum[1]

%---------------------------------------------------------------
\chapter{Architectures}
\ref{chapter:architectures}
In this chapter we will look into classical Monolithic architecture, currently what is considered the most famous called Microservices and what can be found somewhere between: Modulith and Service-Oriented architecture. Apart from defining the architectures, we will compare them among the following lines:
\begin{itemize}
    \item Performance defines how much workload application can handle, how much latency is present during processing and how well application can scale.
    \item Maintainability defines degree to which application is understood, repaired and enhanced from technological perspective.  \cite{SOFTWARE_MAINTAINABILITY}
    \item Sustainability defines how well application performs in long term from business perspective (mainly cost).
    \item Testability defines the extent of how easy or challenging it is to test an application.
    \item Complexity defines how complicated it is to understand the architecture, deployment cycle and implement changes.
\end{itemize}

\input{text/monolith}
\input{text/modulith}
\input{text/microservice}
\input{text/architecture_summary}

\chapter{Example application}
\label{chapter:example_application}
\input{text/example_application}

%---------------------------------------------------------------
\chapter{Case study real application}
\label{chapter:personal_experience}
In this chapter we'll take a closer look at one of the projects I've worked on that was built from the ground up using a microservices architecture. And also on one of my personal projects that I have converted to microservices and later to Modulith. I will share my experience from the position of a backend developer on what it means to work on microservices architecture alone and in a team.  What are the downsides and upsides for developers and the whole application cycle (planning, implementing, bug fixing and deployment).

\input{text/case_study}

%---------------------------------------------------------------
\chapter{Choosing the right architecture}
In software engineering there is no silver bullet. Every project has its spec own specifics and requirements. Some solution can work greatly for one project and be catastrophic for others. In following text, we will look closely on architecture decision-making for projects and try to come up with straight forward methodology.

\input{text/methodology}