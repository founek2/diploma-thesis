\section{Service oriented (SOA)}
In the world of business, creating solutions to automate the execution of business task makes a great sense. Over the course of IT's history, such solutions have been created with a common approach of identifying business task to be automated, defining business requirements and then creating the solution logic \cite{SERVICE_ORIENTED_ARCHITECTURE}. This has been accepted and proven approach to achieving positive business benefits, but it had a few negative sides:
\begin{itemize}
    \item  Repeatedly building "disposable applications" is not the perfect approach.
    \item  Creation of new solution logic in given enterprise commonly results in a significant amount of redundant functionality \cite{SERVICE_ORIENTED_ARCHITECTURE}.
    \item Applications built only with the automation of specific business task in mind, are generally not designed to integrate later with other applications well, resulting in a complex integration architecture.
\end{itemize}
All of those negative aspects listed above led to creation of Service-Oriented architecture with the idea of creating reusable services, requiring high-level of interoperability between service and numerous potential service consumers, with standardized contract, loosely coupled and composable, which requires to be standardized with cross-service data exchange.

\begin{quote}
    `SOA, or service-oriented architecture, defines a way to make software components reusable and interoperable via service interfaces. Services use common interface standards and an architectural pattern so they can be rapidly incorporated into new applications. This removes tasks from the application developer who previously redeveloped or duplicated existing functionality or had to know how to connect or provide interoperability with existing functions.' \cite{IBM_SOA}
\end{quote}

Enterprise contains service inventory, where all services are located and from which the targeted application can be composed as shown on Diagram \ref{img:soa_architecture}. The direct composable property should mitigate traditional perception of integration. Services are designed to be maximally interoperable with the full awareness that they will need to interact with a potentially large range of service consumers, most of will be unknown at the time of their initial delivery \cite{SERVICE_ORIENTED_ARCHITECTURE}. Once a signification part of the enterprise solution logic is represented by services in inventory, it gives freedom to mix these services into infinite composition configurations to match whatever automation task come our way \cite{SERVICE_ORIENTED_ARCHITECTURE}.

\begin{figure}
    \centering
    \includesvg[width=0.7\textwidth]{images/soa_architecture.svg}
    \caption{Services are delivered into service registry (right) from which service composition are drawn (bottom). \label{img:soa_architecture}}
\end{figure}

At a time, companies were launching big organization wide initiatives, to convert everything into Service oriented architecture, which promised a lot of benefits. It was laborious and time-consuming, and often the company's development team had to re-architecture all existing systems as well as design new applications according to new principles. A different way to the problems approach of SOA was Enterpise service bus (ESB), which can be implemented and deployed in a short period. This enabled companies to adopt SOA principles incrementally without needing to rip and replace their entire infrastructure. \cite{ESB_VS_SOA}

A classification is used to indicate the reuse potential of the logic and how the service relates to the actual business logic. The following are common service models:
\begin{itemize}
    \item \textit{Task service} corresponds to single-purpose business process logic. Usually encapsulates the composition logic to compose several other services to complete its task. \cite{ESB_VS_SOA}
    \item \textit{Microservice} has a small functional scope encompassing logic with specific implementation, typically not reusable \cite{ESB_VS_SOA}. (note the term \textit{Microservice} was already used here and later on evolved into its own architecture discussed in section~\ref{section:microservices})
    \item \textit{Entity Service} is a reusable service with one or more related business entities (such as invoice or customer). \cite{ESB_VS_SOA}
    \item \textit{Utility Service} is a reusable service not derived from business analysis encapsulating low-level technology-centric functions, such as notification, logging and security processing. \cite{ESB_VS_SOA}
\end{itemize}


\subsection{Performance}
In SOA, all inputs are validated before one service interacts with another service. Also, to achieve interoperability some translation layer like ESB has to be introduced or organization-wide entity objects, which can get very complex to cover all use cases. All of which adds performance slowdown. Scaling is achieved by adding more instances of targeted service, but since the services can be quite big, it takes some time boot up new instances and prepare environment.

\subsection{Maintainability}
Each service is an independent unit, it advocates parallel development and deployment, it's easy to update and maintain without influencing other services as long as service contract is not broken. Changing service contract requires having some versioning system in-place and maintaining old versions till they are used.

\subsection{Sustainability}

\subsection{Testability}
Independence of services allows easy testing without involving the whole system. On the other hand, testing interoperability with all possible services, which may be unknown at the time of creation is simply impossible.


\subsection{Complexity}
The SOA benefits of being able to compose nearly every task from existing services are great in theory, but the complexity to actually achieved it is big, and many companies failed at it. Recognize business logic, from which service should be created is just first step of many. The most challenging part is the interoperability and standardization. To properly adopt SOA design, it requires re-writing whole system and hiring experienced consultants to properly design solution. And also hiring experienced developers, which needs to first learn our standards and our system, before they can even start implementing anything.