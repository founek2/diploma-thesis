\section{Modulith}
\label{section:modulith}
`Microservice architectures are all the rage these days, but what's really important for long-term maintainability is modularity. It isn't necessary to use a network boundary to create such modules.' \cite{HOW_TO_BUILD_MODULAR_MONOLITH_CONFERENCE_INTRO}

The word \textit{Modulith} is combination of words `Modular' and `Monolith'. In previous section we discussed Monolith architectures and one of them was \textit{Modular monolith} \ref{section:modular_monolith}, which basically enforces separation of logic into modules. Modulith is taking this modular approach even further by enforcing separation not just on logic, but on database/storage as well (see Diagram \ref{img:modulith_architecture}). This way the modules are truly independent on each other, and they are in full control of its data, since now modules has to communicate with others via defined interfaces (this can be done for e.g. directly via inter-process communication, messaging or any other means).

Modules being fully encapsulates gives ability to even run different modules on different nodes/servers and communicate with others over the network and this is basically what Microservices in its nature are. Isolated, independent modules with interface through which they communicate, just they are called `microservices' which should imply the smaller size.

This is an enormous evolution compared to classical Monolith in terms of scaling, since this architecture offers ability to scale just parts of the systems (modules) instead of the whole application. Slow transition to Microservices (discussed in following Section \ref{section:microservices}) is natural step, once the need for scaling arise - just by moving required module into separate service. So the whole application can be build using Modulith architecture, keeping all advantages of Microservices and in the same time removing the biggest disadvantage `distributed system' with the ability to incrementally move to distributed system once it is absolutely necessary.

Modulith is a better structured Monolith with ability to scale. It still has nature of Monolith, so it is deployed as one unit, which gives confidence of matching interfaces across modules, which is something what Microservices architecture is missing, easier debugging since it is not a distributed system and modularity of Microservice architecture for long-term maintainability.

\begin{figure}
    \centering
    \includesvg{images/modulith_architecture.svg}
    \caption{Mondulith architecture. Modules encapsulate logic and its own data. \label{img:modulith_architecture}}
\end{figure}

\subsection{Performance}
Running as a single process, gives this architecture near same properties concerning performance as for Monolith \ref{section:monolith:performance} with a little drawback due to its added abstraction and isolation of data storage across modules. The difference is not big and the modularity is a huge improvement in long-term maintainability. Once some modules are moved into separated service, the negative aspects of distributed system will start appear mainly the network latency, more discussed in Microservice section \ref{section:microservices:performance}.


\subsection{Maintainability}
This is where the Monolith has been proved to be very problematic and the Microservice shines. Enforcing modularity on architecture level turned out to be essential in long-term maintenance. In my experience all projects usually begin as beautiful things and over time gets messy. In my own opinion this is primarily caused my laziness of us developers. If there is some shortcut we can use, we will and say to ourselves: `I will fix it later', which off course never happens. I am not saying this happens all the time, but there are times, when deadlines start breathing on our neck and forcing us to do things faster. So, when we remove some of those shortcuts as were in Monolith, which allowed to do anywhere anything and force modularity on architecture level, developers has no other choice then to do it properly, since there will be no other way. It does mean that some features will take few minutes or hours later, but this will be well invested time compared to searching for mysterious bugs in Monolith in much, much more time is spent.

\subsection{Sustainability}
TODO

\subsection{Testability}
Testing is very similar as for Microservice, since the whole application is split into modules, which can be tested independently. The big advantage even over Microservice is the single process nature, which allows testing using convention tools and frameworks, which were created for Monoliths.

\subsection{Complexity}
In terms of complexity the Modulith architecture sits somewhere between Monolith and Microservice. In its nature it is not a distributed system as Microservices, so there are no network issues and deployment process is as simple as for Monolith. Until we start running modules in separated service, we get partially distributed system, and the complexity arises. The advantages of Modulith is the incremental migration to distributed system and ability to decide whether it is actually needed, because with Microservices we have distributed system from the start even if we want/need it or not. The same apply for implementing transactions, until we start moving towards distributed system the same transaction patterns can be implemented as were for Monolith. Distributed transactions will be discussed later in Microservice section \ref{section:microservices:complexity}.