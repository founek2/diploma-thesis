% Shopify - from Monolith to Modulth https://www.youtube.com/watch?v=ISYKx8sa53g

% System vs application? I want probably refer to app
\section{Monolith}
Probably the most well known architecture praised by some, hated by others is the Monolith.Surprisingly, many people I know do not imagine a properly structured application, but rather `Big ball of mud' \cite{BIG_BALL_OF_MUD} (haphazardly structured, sprawling, sloppy, duct-tape-and-baling-wire, spaghetti-code jungle). Others refer to it as some kind of legacy system that should be eliminated as soon as possible. Of course, there is some truth in all of these statements. Monolithic architecture has been with us since the early days of software development, so there are plenty of legacy systems out there, but we need to understand that they are \textbf{legacy systems}. They were written decades ago, with architectural designs from a time when architectural research was in its early stage. To give some numbers - according to Google Scholar, 20 thousand articles were published about \textit{Software Architecture} until the year 2000 \cite{SCHOLAR_2000} and from 2001 to 2023 it was over 244 thousand \cite{SCHOLAR_2001_2023}. The progress in software architecture has been enormous in the last two decades, and new concepts for monolithic architectures have also been created.

In this section, I'm going to go into detail about what a monolith is, what it isn't, what new approaches are available, and try to clear up some common misconceptions. When I talk about monoliths, I am primarily referring to a unit of deployment\cite{MON_TO_MS_MONOLITH}. \textit{When all functionality in a system has to be deployed together, we consider it a monolith \cite{MON_TO_MS_MONOLITH}.} There are at least three types of monolithic systems that fit this description: the single-process system, the modular monolith, and the distributed monolith \cite{BUILDING_MS_MONOLITH}.


% Starting high level
\subsection{The Single process Monolith}
The most common example of a system where all the code is deployed as a single process, as in Figure~\ref{img:monolith_single_process}. There may be multiple instances of this process running for scalability or availability, but essentially all the code is packed into a single process. Typically, these single-process systems can be simple distributed systems in themselves, as they almost always end up reading data from or writing data to a database. \cite{MON_TO_MS_MONOLITH}

These single-process monoliths probably represent the vast majority of monolithic systems. There is no clear boundary between individual parts and the whole application is highly coupled \cite{EVOLUTIONARY_ARCHITERUES_COUPLING}, meaning that changing one part of the system inevitably affects other parts.

\begin{figure}
    \centering
    \includesvg{images/monolith_single_process.svg}
    \caption{A single process monolith: all code is packaged into a single process. \cite{MON_TO_MS_MONOLITH}\label{img:monolith_single_process}}
\end{figure}


% -------------------------------------------------------
\subsection{The Modular Monolith}
\label{section:modular_monolith}

The modular monolith is a subset of the single-process monolith, where the single process is composed of distinct modules. Although each module can be worked on separately, deployment still requires all modules to be assembled into a single unit, as shown in Figure \ref{img:monolith_single_process_modular}. \cite{BUILDING_MS_MONOLITH}

This is a nice evolutionary step for monolithic systems. Well-defined module boundaries can allow a high degree of parallelism while avoiding the challenges associated with distributed microservice architecture and still having a simple deployment topology \cite{BUILDING_MS_MONOLITH}.

The biggest problem with this architecture is that although the logic is separated into modules, the storage is usually monolithic and represented by a database of relationships. This means that the separation is not effectively applied to the data, but only to the code.


\begin{figure}
    \centering
    \includesvg{images/monolith_single_process_modular.svg}
    \caption{In a modular monolith, the code inside the process is divided into modules. \cite{BUILDING_MS_MONOLITH}\label{img:monolith_single_process_modular}}
\end{figure}


% -------------------------------------------------------
\subsection{The Distributed Monolith}
\begin{quote}
    A distributed system is one in which the failure of a computer you didnâ€™t even know existed can render your own computer unusable. \cite{lamport1987distribution}
    \begin{flushright}
        - Leslie Lamport
    \end{flushright}
\end{quote}

A distributed monolith is a system that consists of multiple services, but for some reason the entire system needs to be deployed together. A distributed monolith may well meet the definition of a service-oriented architecture, but all too often it fails to deliver on the promise of SOA. Distributed monoliths usually have all the disadvantages of a distributed system, and the disadvantages of a single-process monolith, without having enough upsides of either. \cite{MON_TO_MS_MONOLITH}

Distributed monoliths typically arise in an environment where there has been insufficient focus on concepts such as information hiding and cohesion of business functionality, leading instead to highly coupled architectures where changes ripple across service boundaries and seemingly innocent changes that appear local in scope break other parts of the system \cite{MON_TO_MS_MONOLITH}. In general, there is no reason to choose this distributed architecture over microservices, as it has many drawbacks and should be avoided, except when moving from monolith to microservices, where it may become an intermediate step \cite{DIST_MON_WHICH_BUILDING}.

I include this type of monolith for completeness, but since it is discouraged, I will not refer to it unless explicitly stated.

% -------------------------------------------------------
\subsection{Service Oriented Architecture (SOA)}
In the business world, creating solutions to automate the execution of business tasks makes a lot of sense. Throughout the history of IT, such solutions have been built using a common approach of identifying the business task to be automated, defining the business requirements and then building the solution logic \cite{SERVICE_ORIENTED_ARCHITECTURE}. This has been an accepted and proven approach to achieving positive business benefits, but it has had some negative sides:
\begin{itemize}
    \item  Repeatedly building ``disposable applications" is not the perfect approach.
    \item  The creation of new solution logic in a given enterprise typically results in a significant amount of redundant functionality\cite{SERVICE_ORIENTED_ARCHITECTURE}.
    \item Applications built only with the automation of specific business task in mind, are generally not designed to integrate later with other applications well, resulting in a complex integration architecture.
\end{itemize}
All of those negative aspects listed above led to creation of Service-Oriented architecture with the idea of creating reusable services, requiring high-level of interoperability between service and numerous potential service consumers, with standardized contract, loosely coupled and composable, which requires to be standardized with cross-service data exchange.

Service-oriented architecture, or SOA, describes how to use service interfaces to make software components interoperable and reusable. By using an architectural pattern and common interface standards, services can be quickly integrated into new applications. As a result, the application developer is relieved of duties that previously required them to rewrite or replicate existing functionality or figure out how to link or ensure interoperability with it. \cite{IBM_SOA}

In the early days, companies launched major organisation-wide initiatives to convert everything to a service-oriented architecture, which promised many benefits. However, the process was cumbersome and time-consuming, often requiring the company's development team to re-architect all existing systems and design new applications according to new principles. A different way of approaching the problems of SOA was the Enterprise Service Bus (ESB), which can be implemented and deployed in a short time and acts as a central solution for integrations. The ESB approach was quickly adopted and is now used by virtually every company that has an SOA architecture. It allows existing legacy systems to be preserved, simply by exposing services from them via API and creating the integration through the ESB.

Every enterprise contains a service inventory, where all the services are located and from which the target application can be composed, as shown in Figure~\ref{img:soa_architecture}. The directly composable property should have mitigated the traditional perception of integration, but in reality it has just moved into the ESB. Once a significant part of the enterprise solution logic is represented by services in the inventory, the freedom to mix these services into infinite composition configurations to match whatever automation task comes our way \cite{SERVICE_ORIENTED_ARCHITECTURE}.

A classification is used to indicate the reuse potential of the logic and how the service relates to the actual business logic. The common service models are: Task service, Entity service, Utility service and microservice (this is different microservice than we know today, in SOA it was used for small implementation specific service, which was not reusable). \cite{SERVICE_ORIENTED_ARCHITECTURE}

The complexity of implementation to achieve true reusability is huge and has noticeable performance drawbacks, not to mention high maintenance costs. In practice, this architecture has mostly been implemented in large existing companies that already had some legacy systems and combined with the ESB to create huge highly coupled monoliths. Today, everyone is moving away from this architecture, if they have not already done so, towards microservices (section~\ref{section:microservices}), which have proven to be better for the job.

\begin{figure}
    \centering
    \includesvg[width=0.7\textwidth]{images/soa_architecture.svg}
    \caption{Services are delivered into service inventory (right) from which service composition are drawn (bottom). \label{img:soa_architecture}}
\end{figure}

% -------------------------------------------------------

% Going more low level - developer point of view, maybe some example?
\newpage
\subsection{Characteristics}

\subsubsection{Performance}
\label{section:monolith:performance}
Deploying as a single process gives a huge performance advantage over any kind of distributed system, because network communication is subject to the laws of physics and always adds latency. Inter-process communication, on the other hand, has the lowest possible latency, making the monolith theoretically the fastest architecture out there. This rule applies until the need to scale the application arises and vertical scaling is no longer an option. Since the whole system is deployed as a single unit, horizontal scaling means running multiple instances of the whole monolith, which in most cases is not very efficient, because the system is usually not evenly loaded, but some parts of the system are doing most of the work, and we still have those other parts taking up resources when we don't actually need them.


% latency
% throughput
% scalability
% 

\subsubsection{Maintainability}
Maintenance is closely related to complexity. Usually, the more complex the application, the harder it is to maintain, and with monolithic high coupling it is very bad at it. A single change can have the power to affect the entire application, and maintaining legacy monoliths has become a nightmare for many developers, as even the smallest change requires extensive knowledge of the whole system. Although there are some positive sides, debugging and logging is much easier than with any kind of distributed system, so finding the problem is usually the easy step compared to creating the actual fix.

% Easy debugging | logging

\subsubsection{Sustainability}
% Not sure what should be here
The maintenance costs of monolith are huge, as are the operational costs due to its inability to scale properly, so we have to have an oversized infrastructure, but also developers with extensive knowledge of the system and a well-defined testing process. Introducing any kind of architectural change is almost impossible and integrations have also proven to be complicated/problematic.

\subsubsection{Testability}
Since there are no boundaries in the classic monolith, it is almost impossible to test only certain parts of the system in isolation, because the whole system has to be present for it to work. So writing end-to-end tests is usually the answer, but it is much harder to write and even execute them, because they take much more time than just testing isolated parts.

With a modular monolith, testing is much easier because you can test only specific modules. The tests are smaller, which results in higher speed, and are easier to write because the developer can focus only on the specific part of the system.

\subsubsection{Complexity}
High coupling makes it very hard to do any modification, because it requires vast knowledge of the whole system and as the developer team grows they start to get into each other way, wanting to change the same piece of code. It also creates confusion about who owns the code and who makes the decisions \cite{MON_TO_MS_MONOLITH}.

The architecture itself (single process or distributed monolith) imposes no restrictions on how the application should be structured and gives the developer maximum freedom. In my experience, this has proved fatal in many projects as it is a heavy burden and if not properly designed at the outset and kept under control throughout the development cycle, it can very easily lead to a `big ball of mud' \cite{BIG_BALL_OF_MUD}.

% TODO: Take into account database coupling of records and how Modulth does it
High coupling is one of the reasons why the Modular Monolith was created. It retains all the positive characteristics of the single-process monolith, while reducing the coupling by defining boundaries within the monolith. It is then up to the developers to properly define and enforce these boundaries - this step is very important because less experienced developers often tend to simplify their work at the expense of the architecture.

Deployment is very simple compared to any kind of distributed system, as there is only one unit. The downside is the size of the unit, not even because of space (we have a pretty fast network and cheap disk space), but rather higher resource usage and much slower startup compared to a microservice.

% release complexity
On the other hand, when there are multiple teams working on a monolithic system, release planning requires close cooperation between all development teams to ensure that everything that goes into the build is production ready. This tends to lead to slow deployment cycles, where releases are deployed every few months, which does not cope well with today's requirements to deploy much more frequently (e.g. Agile methodology \cite{AGILE_MANIFESTO}).

% Dev tools stack