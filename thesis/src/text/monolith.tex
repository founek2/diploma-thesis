% Shopify - from Monolith to Modulth https://www.youtube.com/watch?v=ISYKx8sa53g

% System vs application? I want probably refer to app
\section{Monolith}
Probably the most well known architecture praised by some, hated by others is the Monolith. Surprisingly a lot of people I know do not imagine a properly structured application, but rather `Big ball of mud' \cite{BIG_BALL_OF_MUD} (haphazardly structured, sprawling, sloppy, duct-tape-and-baling-wire, spaghetti-code jungle). Others refer to it as some kind of legacy system, which should be eliminated as soon as possible. Off course there is some truth in all of those statements. Monolithic architecture is with us from early days of software development, so lots of legacy systems exists, but we have to understand that they are \textbf{legacy systems}. They were written decades ago, with architecture design of that time when architecture research was at the beginning. To state some numbers - according to Google Scholar 20 thousands articles were published about \textit{Software architecture} until year 2000 \cite{SCHOLAR_2000} and from 2001 until 2023 it was over 244 thousands \cite{SCHOLAR_2001_2023}. The progress in software architecture was huge over the last two decades and new concepts for Monolithic architectures were created as well.

In this section we are going to dig deep into what Monolith is and isn't, what are new approaches, and we'll try to eliminate common misconceptions. When I talk about the monoliths, I am primarily referring to a unit of deployment\cite{MON_TO_MS_MONOLITH}. \textit{When all functionality in a system has to be deployed together, we consider it a monolith \cite{MON_TO_MS_MONOLITH}.} There are at least three types of monolithic systems that fit the bill: the single-process system, modular monolith and distributed monolith \cite{BUILDING_MS_MONOLITH}.


% Starting high level
\subsection{The Single process Monolith}
The most common example of system in which all the code is deployed as a single process, as in Figure~\ref{img:monolith_single_process}. There might be multiple instances of this process running for scaling or availability, but fundamentally all the code is packed into single process. Usually these single-process systems can be simple distributed systems on their own as nearly always end up reading data from or storing data into a database. \cite{MON_TO_MS_MONOLITH}

These single-process monoliths probably represent the vast majority of the monolithic systems. There is not any clear boundary between individual parts and whole application is highly coupled \cite{EVOLUTIONARY_ARCHITERUES_COUPLING} meaning changing any part of the system inevitably results in affecting other parts as well.

\begin{figure}
    \centering
    \includesvg{images/monolith_single_process.svg}
    \caption{A single process monolith: all code is packaged into a single process. \cite{MON_TO_MS_MONOLITH}\label{img:monolith_single_process}}
\end{figure}


% -------------------------------------------------------
\subsection{The Modular Monolith}
\label{section:modular_monolith}

The modular monolith is a subset of the single-process monolith, where the single process is composed of distinct modules. Although each module can be worked on separately, deployment still requires all modules to be merged together into single unit as shown in Figure \ref{img:monolith_single_process_modular}. \cite{BUILDING_MS_MONOLITH}

It represents nice evolution step for Monolithic systems. Well-defined module boundaries can allow for a high degree of parallel work, while avoiding challenges associated with distributed microservice architecture and still have simple deployment topology \cite{BUILDING_MS_MONOLITH}.

The biggest problem with this architecture is that although the logic is separated into modules, the storage is usually monolithic and represented by a database with relationships. This means that the separation is not effectively applied to data, but only to code.


\begin{figure}
    \centering
    \includesvg{images/monolith_single_process_modular.svg}
    \caption{In a modular monolith, the code inside the process is divided into modules. \cite{BUILDING_MS_MONOLITH}\label{img:monolith_single_process_modular}}
\end{figure}


% -------------------------------------------------------
\subsection{The Distributed Monolith}
\begin{quote}
    A distributed system is one in which the failure of a computer you didnâ€™t even know existed can render your own computer unusable. \cite{lamport1987distribution}
    \begin{flushright}
        - Leslie Lamport
    \end{flushright}
\end{quote}

A distributed monolith is a system that consists of multiple services, but for whatever reason the entire system has to be deployed together. A distributed monolith may well meet the definition of a service-oriented architecture, but all too often fails to deliver on the promises of SOA. Distributed monoliths usually have all the disadvantages of a distributed system, and the disadvantages of a single-process monolith, without having enough upsides of either. \cite{MON_TO_MS_MONOLITH}

Distributed monoliths typically emerge in an environment where not enough focus was placed on concepts like information hiding and cohesion of business functionality, leading instead to highly coupled architectures in which changes ripple across service boundaries, and seemingly innocent changes that appear to be local in scope break other parts of the system \cite{MON_TO_MS_MONOLITH}. Generally there is no reason why to choose this distributed architecture over microservices, because it comes with a lot of disadvantages and should be avoided with exception being conversion from monolith to microservices where this might become an intermediate step \cite{DIST_MON_WHICH_BUILDING}.

I am including this type of Monolith for the completeness, but since it is discouraged I will not refer to it unless explicitly specified.

% -------------------------------------------------------
\subsection{Service Oriented Architecture (SOA)}
In the world of business, creating solutions to automate the execution of business task makes a great sense. Over the course of IT's history, such solutions have been created with a common approach of identifying business task to be automated, defining business requirements and then creating the solution logic \cite{SERVICE_ORIENTED_ARCHITECTURE}. This has been accepted and proven approach to achieving positive business benefits, but it had a few negative sides:
\begin{itemize}
    \item  Repeatedly building ``disposable applications" is not the perfect approach.
    \item  Creation of new solution logic in given enterprise commonly results in a significant amount of redundant functionality \cite{SERVICE_ORIENTED_ARCHITECTURE}.
    \item Applications built only with the automation of specific business task in mind, are generally not designed to integrate later with other applications well, resulting in a complex integration architecture.
\end{itemize}
All of those negative aspects listed above led to creation of Service-Oriented architecture with the idea of creating reusable services, requiring high-level of interoperability between service and numerous potential service consumers, with standardized contract, loosely coupled and composable, which requires to be standardized with cross-service data exchange.

Service-oriented architecture, or SOA, describes how to use service interfaces to make software components interoperable and reusable. Services can be quickly integrated into new applications by using an architectural pattern and common interface standards. As a result, the application developer is relieved of duties that previously required them to rewrite or replicate existing functionality or figure out how to link or ensure interoperability with it. \cite{IBM_SOA}

At the start, companies were launching big organization wide initiatives, to convert everything into Service oriented architecture, which promised a lot of benefits. It was laborious and time-consuming, and often the company's development team had to re-architecture all existing systems as well as design new applications according to new principles. A different way to approach problems of SOA was Enterpise service bus (ESB), which can be implemented and deployed in a short period of time acting as a central solution for integrations. This approach with ESB has been quickly adopted and basically everyone in business who have SOA architecture is using it. It allows preserving existing legacy Modulith systems, just by exposing from them service via API and creating integration through ESB.

Every enterprise contains service inventory, where all services are located and from which the targeted application can be composed as shown on Figure~\ref{img:soa_architecture}. The direct composable property should have mitigated traditional perception of integration, but in reality it just moved into ESB. Once a signification part of the enterprise solution logic is represented by services in inventory, which gives freedom to mix these services into infinite composition configurations to match whatever automation task come our way \cite{SERVICE_ORIENTED_ARCHITECTURE}.

A classification is used to indicate the reuse potential of the logic and how the service relates to the actual business logic. The common service models are: Task service, Entity service, Utility service and microservice (this is different microservice than we know today, in SOA it was used for small implementation specific service, which was not reusable). \cite{SERVICE_ORIENTED_ARCHITECTURE}

The complexity of implementation to achieve actual reusability is huge and has noticeable performance drawbacks, not to mention high cost in maintainability. In practice this architecture has been mostly implemented into big existing companies, which had already some existing legacy systems and in combination with ESB giant high coupled Monoliths were created. Today everyone is moving away from this architecture if they did not already towards microservices (section~\ref{section:microservices}), which has proven to be better suited for the task.

\begin{figure}
    \centering
    \includesvg[width=0.7\textwidth]{images/soa_architecture.svg}
    \caption{Services are delivered into service inventory (right) from which service composition are drawn (bottom). \label{img:soa_architecture}}
\end{figure}

% -------------------------------------------------------

% Going more low level - developer point of view, maybe some example?

\subsection{Characteristics}

\subsubsection{Performance}
\label{section:monolith:performance}
Deployment as a single process brings big benefit in terms of performance compared to any type of distributed system, because network comunication is subject to the laws of physics and always add latency. Whereas inter process communication has the lowest latency possible making Monolith in theory the fastest architecture out here. This rule will apply, until the need to scale the application arises and vertical scaling is not an option anymore. Since the whole system is deployed as one unit, horizontal scaling means running multiple instances of the whole monolith, which is in most cases not very efficient, because usually the system does not have uniform load, but some parts of the system does the most of the work, and we still have those other parts taking up resources even though we actually don't even need them.


% latency
% throughput
% scalability
% 

\subsubsection{Maintainability}
Maintenance is tightly related to Complexity. Usually the more complex application, the more hard to maintain and with monolithic high coupling it is very bad at it. A single modification can have power to affect the entire application and maintaining legacy Monoliths has become nightmare for many developers, since even smallest change requires vast knowledge of the whole system. Although there are some positive sides, having debugging and logging much easier than with any kind of distributed system, so finding the issue is usually the simple step compared to creating the actual fix.

% Easy debugging | logging

\subsubsection{Sustainability}
% Not sure what should be here
The maintenance cost of Monolith is huge. Either the operational costs due to its inability to scale properly, so we have to have oversized infrastructure, but also having developers with vast knowledge of the system and well-defined testing process. Introducing any kind of architecture change is nearly impossible and integrations have proven to be complicated/problematic as well.

\subsubsection{Testability}
Since in classical monolith, there are no boundaries, it is nearly impossible to test just specific parts of the system in isolation, because the whole system needs to be present in order for it to function. So, writing end-to-end tests is usually the answer, but it has much harder to write and even run them, because they take much more time, compared to testing just isolated parts.

With modular monolith, the testing is much easier, since it allows testing just specific modules. The tests are smaller, which results in higher speed and are easier to write, because developer can focus just on the specific part of the system.

\subsubsection{Complexity}
High coupling makes it very hard to do any modification, because it requires vast knowledge of the whole system and as the developer team grows they start to get into each other way, wanting to change the same piece of code. Also, confusion around ownership of the code arouses and who makes the decisions \cite{MON_TO_MS_MONOLITH}.

The architecture itself (Single process or distributed monolith) does not enforce any kind of restriction on how the application should be structured and gives developer maximal freedom. In my experience this has proven as fatal in many projects, since it presents heavy burden and if not properly designed in the beginning and kept in check during the whole development cycle, it can very easily lead to `Big ball of mud' \cite{BIG_BALL_OF_MUD}.

% TODO: Take into account database coupling of records and how Modulth does it
The high coupling is one of the reasons why the Modular Monolith was created. It preserves all those positive properties of Single process Monolith, while decreasing coupling by defining boundaries inside monolith. It is than again up to developers to properly define those boundaries and enforce them - this step is very important, because less experienced developers often tend to simplify their work at expense of architecture.

Deployment is very simple compared to any kind of distributed system, since there is just one unit. The downside being size of the unit, not even because of space (we have pretty fast network and cheap disk space), but rather higher resource usage and much slower startup compared to microservice.

% release complexity
On the other hand, when there are multiple teams working on Monolithic system, planning the release requires close cooperation of all development teams, so everything of what gets into build is production ready. This usually leads to slow deployment cycles, where release is deployed every few months, which does not cope well with today requirements to deploy much more often (e.g. Agile methodology \cite{AGILE_MANIFESTO}).

% Dev tools stack