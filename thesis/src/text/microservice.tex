\section{Microservices}
\label{section:microservices}
Many people consider this architecture as solution for every problem. What architecture for new project? Microservices. Is your application slow? Convert it to Microservices. Experiencing slow development? Microservices are the solution. Fair enough, it really does change the game and there are definitely projects where it is the best possible solution. Although in my experience, people tend to use this architecture carelessly as the only correct solution, ignoring its disadvantages, and there are definitely projects where for example monolith would be more suited for task and save a lot of money and time. So what exactly is it?


Microservices are services that can be released independently and are modeled around a business domain. A service is a building element from which you create a more complicated system. It encapsulates functionality and makes it available to other services via networks. A single microservice may represent inventory, another order processing, and another shipping, but taken as a whole, they could make up a whole e-commerce system. Microservices are an architecture approach that aims to provide you with a multiple of solutions for resolving potential issues. \cite{BUILDING_MS_WHAT_ARE}

They are a kind of service-oriented architecture, even if they have strong opinions about the appropriate way to define service boundaries and emphasize the importance of independent deployability. One of the benefits they have is that they are technology-agnostic. \cite{BUILDING_MS_WHAT_ARE}


From a technology viewpoint, microservices expose the business capabilities that they encapsulate via one or more network endpoints \cite{MON_TO_MS_MICROSERVICE} (for example, a queue or a REST API \cite{BUILDING_MS_WHAT_ARE}, as shown in Figure~\ref{img:microservices_basic}). Microservices communicate with each other via these networks â€” making them a form of distributed system. They also encapsulate data storage and retrieval, exposing data, via well-defined interfaces. So databases are hidden inside the service boundary. \cite{MON_TO_MS_MICROSERVICE}

Compared to the discussed Modulith in section \ref{section:modulith}, Microservices are taking the whole modular concept one step further. Instead of primarily building the application around modules with possibility to extract module into separate service to scale it, they are building the whole application from the ground around services with network boundaries fully embracing scalability. This is where I see the problem with building new applications with Microservices architecture from the start when there is no idea about system load, performance issues or just about anything. I would compare it to `Premature optimization' in programming - why spend a lot of time building super scalable system, when we do not even know yet if we will ever need it?

% how to find correct size of microservice
What is the correct size of a single Microservice? The \textit{micro} part of the word is misleading. The Microservices were created primarily for needs of big companies and original idea behind it was to have a dedicated team of developers behind every Microservice. And this is something, which is not possible in most of the companies with just couple of developers. The practice I have seen in reality is, that just couple of developers are running dozens of microservices or even in one project I was single developer managing over 20 microservices (more in Chapter \ref{chapter:personal_experience}). The `micro' just means completely different thing for big companies like Netflix or Amazon and for small/medium projects.

Building Microservice architecture requires a lot of planning to properly set boundaries to individual services and keep an eye on it. It is much harder to do bigger refactoring compared to Monolithic architecture even though it should be easier due to the service isolation. Unfortunately in practice due to business requirements it is impossible to create something completely independent. Example: Lets imagine we have microservice with some HTTP API, which we need to split. Other service are communicating with it through the API. We need to hold the compatibility for API for a long time, since we most likely do not know exactly which services are using which API, thus it is not safe to remove anything. So, we split the service, the old service will have the full original API, the new service just the part of the API, which it can handle. For the old service additional backward compatibility logic needs to be implemented for those parts of API, which were moved to second service. And this compatibility needs to be maintained for unspecified period of time - this depend if we have any strategy how to safely remove something and make sure it does not break other parts of system. On other hand in Modulith we would just split the one module into two, and we very easy find all places which uses the old functionality and update it accordingly - how to find it? IDE (basic feature `find usage'), compiler, static code analyses. The compiler makes sure automatically all interfaces and implementations are compatible, and it does for free out of box. Just something, which is not easily possible in Microservices world.


\begin{figure}
    \centering
    \includesvg[width=0.7\textwidth]{images/Microservices_basic.svg}
    \caption{A microservice exposing its functionality over a REST API and a topic. \cite{BUILDING_MS_WHAT_ARE}\label{img:microservices_basic}}
\end{figure}



\subsection{Brief history}
Dr. Peter Rodgers during a presentation in 2005 used the term `Micro-web-Services' on topic of cloud computing. Rodgers promoted software components supporting micro-web-services. The first usage of the term ``microservices" is to believed to be first heard in May, 2011, in a workshop for software architects, where they use it to describe an architectural style several of them had recently explored. Later on in 2012, the term was formally adopted. They had been experimenting with building continuously deployed systems, while incorporating the DevOps philosophy. From there this form of the architecture quickly gained popularity. \cite{BRIEF_HISTORY_OF_MS}

% TODO add sources
Netlix is a company considered as pioneer in Microservices adoption together with Amazon, which was more focusing on Cloud computing. Also, other large companies joined the ride like Uber, Etsy and many more. This architecture was the answer companies were looking for, due to its ability to offer agility, scalability and ability to adapt to changing business requirements. \cite{MS_COMPANIES}



\subsection{Characteristics}
\subsubsection{Performance}
\label{section:microservices:performance}
Microservices being distributed system, it necessarily adds higher latency compared to Monolithic systems, but it brings many advantages which can easily balance this negative side. The biggest being the scalability. Microservices are very small unis, which can usually start up in couple of seconds, so it can be scaled based on current workload fully leveraging cloud computing and pricing per usage rather having oversized infrastructure. On other hand scaling does not work out of the box and it requires system to support it. Also, it is not possible to scale up infinitly and some bottleneck will stand out, usually being database.


\subsubsection{Maintainability}
% Distributed tracing
Distributed system are much harder to maintain due to added complexity. Even thing like investigating some issue requires collecting logs from multiple servers, aggregating them together and having tool to effectively search through it. Or even better way is to use Distributed tracing, which can generate vast amount of data even on simple systems. Modifications in microservices have isolated effect withing microservice and can be deployed in matter of just few hours (or even minutes).

\subsubsection{Sustainability}
The isolated microservices give big flexibility and allows for faster iterations (even faster than Modulith) to better adapt for changing business requirements as well as for architecture change.

\subsubsection{Testability}
In theory testing should be breeze, but in really not so much, because services are usually part of a larger business-logic dependent on other services to complete the logic. Practices for service-testing (e.g. mocks, API-contract testing) are known, but they are very complex and costly to implement. For comparison in  monoliths we have many proved testing strategies including end-to-end with many great frameworks/libraries available. \cite{MC_TESTABILITY}

Service can often become inaccessible, due to issue on many layers of network or security operated by an orchestrating software. These kinds of problems are hard to simulate in-order to prevent faults from reaching production.

\subsubsection{Complexity}
\label{section:microservices:complexity}
% orchestrator + deployment
Breaking whole system into isolated `micro' pieces (services) makes it easier for developers to implement new features and work independently, but it definitely makes the whole system more complicated, because of added network communication and more complicated deployment. Network communication is required for inter-service communication and also for outside world, and there is a lot we can choose from. Starting from classical patterns like request-response or more data driven approaches like observer or publish-subscribe.
% TODO dive more deep into communication 

Managing deployment of microservices is a big task and over the years lot of automation tools were created. Today standard way on how to deploy applications with rise of Docker became containers, due to its self-containement, isolation and ability to run absolutely anywhere \cite{7093032}. Container Orchestration make deployment and maintenance much easier thanks to automatization - examples: Kubernetes\cite{KUBERNETES}, Nomad\cite{NOMAD}. It takes care of whole lifecycle of the application and even auto-scaling. Unfortunately, managing those tools is a big challenge on its own, but thankfully nowadays we can get fully managed orchestrators `as a Service', so we can fully focus on building our system and not on infrastructure.

% TODO more deep into example technology stack - maybe later in comparison chapter

% Distributed transactions
Distributed transactions have the same processing requirements as regular database transactions, but they must be managed across multiple resources, making them more challenging to implement. When ACID transactions are required, the 2PC \cite{2PC_PATTERN} (two-phase commit) architecture with central transaction coordinator is a one solution. On the other, hand if eventual consistency is enough, there is SAGA pattern \cite{SAGA_PATTERN}, which works sequentially.

% language and technology agnostic
Language and technology-agnostic is another advantage presented around Microservices. A personally perceive it as negative for small teams, where few developers manages dozens of Microservices and they would have to constantly switch context. But it is great trait for large teams, where ideally one team has just one or couple of microservices. It gives a lot of freedom and developers like to play with every new shining piece of software/technology, which can result (if unchecked) in technology jungle to which no one understands and is unable to maintain. The same applies for languages. Although I am strong advocate for always using language for the right task, it must be well argued and everyone on the team should be familiar with it, because in small teams there is usually shared code ownership.

