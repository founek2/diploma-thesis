\section{Microservices}
\label{section:microservices}
Many people consider this architecture as solution for every problem. What architecture for new project? Microservices. Is your application slow? Convert it to Microservices. Experiencing slow development? Microservices are the solution. Fair enough, it really does change the game and there are definitely projects where it is the best possible solution. Although in my experience, people tend to use this architecture carelessly as the only correct solution, ignoring its disadvantages, and there are definitely projects where for example monolith would be more suited for task and save a lot of money and time. So what exactly is it?


Microservices are services that can be released independently and are modeled around a business domain. A service is a building element from which you create a more complicated system. It encapsulates functionality and makes it available to other services via networks. A single microservice may represent inventory, another order processing, and another shipping, but taken as a whole, they could make up a whole e-commerce system. Microservices are an architecture approach that aims to provide you with a multiple of solutions for resolving potential issues. \cite{BUILDING_MS_WHAT_ARE}

They are a kind of service-oriented architecture, even if they have strong opinions about the appropriate way to define service boundaries and emphasize the importance of independent deployability. One of the benefits they have is that they are technology-agnostic. \cite{BUILDING_MS_WHAT_ARE}


From a technology viewpoint, microservices expose the business capabilities that they encapsulate via one or more network endpoints \cite{MON_TO_MS_MICROSERVICE} (for example, a queue or a REST API \cite{BUILDING_MS_WHAT_ARE}, as shown in Figure~\ref{img:microservices_basic}). Microservices communicate with each other via these networks â€” making them a form of distributed system. They also encapsulate data storage and retrieval, exposing data, via well-defined interfaces. So databases are hidden inside the service boundary. \cite{MON_TO_MS_MICROSERVICE}

Compared to the discussed Modulith in section \ref{section:modulith}, Microservices are taking the whole modular concept one step further. Instead of primarily building the application around modules with possibility to extract module into separate service to scale it, they are building the whole application from the ground around services with network boundaries fully embracing scalability. This is where I see the problem with building new applications with Microservices architecture from the start when there is no idea about system load, performance issues or just about anything. I would compare it to `Premature optimization' in programming - why spend a lot of time building super scalable system, when we do not even know yet if we will ever need it?

% how to find correct size of microservice
What is the correct size of a single Microservice? The \textit{micro} part of the word is misleading. The Microservices were created primarily for needs of big companies and original idea behind it was to have a dedicated team of developers behind every Microservice. And this is something, which is not possible in most of the companies with just couple of developers. The practice I have seen in reality is, that just couple of developers are running dozens of microservices or even in one project I was single developer managing over 20 microservices (more in Chapter \ref{chapter:personal_experience}). The `micro' just means completely different thing for big companies like Netflix or Amazon and for small/medium projects.

Building Microservice architecture requires a lot of planning to properly set boundaries to individual services and keep an eye on it. It is much harder to do bigger refactoring compared to Monolithic architecture even though it should be easier due to the service isolation. Unfortunately in practice due to business requirements it is impossible to create something completely independent. Example: Lets imagine we have microservice with some HTTP API, which we need to split. Other service are communicating with it through the API. We need to hold the compatibility for API for a long time, since we most likely do not know exactly which services are using which API, thus it is not safe to remove anything. So, we split the service, the old service will have the full original API, the new service just the part of the API, which it can handle. For the old service additional backward compatibility logic needs to be implemented for those parts of API, which were moved to second service. And this compatibility needs to be maintained for unspecified period of time - this depend if we have any strategy how to safely remove something and make sure it does not break other parts of system. On other hand in Modulith we would just split the one module into two, and we very easy find all places which uses the old functionality and update it accordingly - how to find it? IDE (basic feature `find usage'), compiler, static code analyses. The compiler makes sure automatically all interfaces and implementations are compatible, and it does for free out of box. Just something, which is not easily possible in Microservices world.


\begin{figure}
    \centering
    \includesvg[width=0.7\textwidth]{images/Microservices_basic.svg}
    \caption{A microservice exposing its functionality over a REST API and a topic. \cite{BUILDING_MS_WHAT_ARE}\label{img:microservices_basic}}
\end{figure}



\subsection{Brief history}
Dr. Peter Rodgers during a presentation in 2005 used the term `Micro-web-Services' on topic of cloud computing. Rodgers promoted software components supporting micro-web-services. The first usage of the term ``microservices" is to believed to be first heard in May, 2011, in a workshop for software architects, where they use it to describe an architectural style several of them had recently explored. Later on in 2012, the term was formally adopted. They had been experimenting with building continuously deployed systems, while incorporating the DevOps philosophy. From there this form of the architecture quickly gained popularity. \cite{BRIEF_HISTORY_OF_MS}

% TODO add sources
Netlix is a company considered as pioneer in Microservices adoption together with Amazon, which was more focusing on Cloud computing. Also, other large companies joined the ride like Uber, Etsy and many more. This architecture was the answer companies were looking for, due to its ability to offer agility, scalability and ability to adapt to changing business requirements. \cite{MS_COMPANIES}



\subsection{Characteristics}
\subsubsection{Performance}
\label{section:microservices:performance}
Microservices being distributed system, it necessarily adds higher latency compared to Monolithic systems, but it brings many advantages which can easily balance this negative side. The biggest being the scalability. Microservices are very small unis, which can usually start up in couple of seconds, so it can be scaled based on current workload fully leveraging cloud computing and pricing per usage rather having oversized infrastructure. On other hand scaling does not work out of the box and it requires system to support it. Also, it is not possible to scale up infinitly and some bottleneck will stand out, usually being database.


\subsubsection{Maintainability}
% Distributed tracing
Distributed system are much harder to maintain due to added complexity. Even thing like investigating some issue requires collecting logs from multiple servers, aggregating them together and having tool to effectively search through it. Or even better way is to use Distributed tracing, which can generate vast amount of data even on simple systems. Modifications in microservices have isolated effect withing microservice and can be deployed in matter of just few hours (or even minutes).

\subsubsection{Sustainability}
The isolated microservices give big flexibility and allows for faster iterations (even faster than Modulith) to better adapt for changing business requirements as well as for architecture change.

\subsubsection{Testability}
In theory testing should be breeze, but in really not so much, because services are usually part of a larger business-logic dependent on other services to complete the logic. Practices for service-testing (e.g. mocks, API-contract testing) are known, but they are very complex and costly to implement. For comparison in  monoliths we have many proved testing strategies including end-to-end with many great frameworks/libraries available. \cite{MC_TESTABILITY}

Service can often become inaccessible, due to issue on many layers of network or security operated by an orchestrating software. These kinds of problems are hard to simulate in-order to prevent faults from reaching production.

\subsubsection{Complexity}
\label{section:microservices:complexity}
% orchestrator + deployment
Breaking whole system into isolated `micro' pieces (services) makes it easier for developers to implement new features and work independently, but it definitely makes the whole system more complicated, because of added network communication and more complicated deployment. Network communication is required for inter-service communication and also for outside world, and there is a lot we can choose from. Starting from classical patterns like request-response or more data driven approaches like observer or publish-subscribe.
% TODO dive more deep into communication 

Managing deployment of microservices is a big task and over the years lot of automation tools were created. Today standard way on how to deploy applications with rise of Docker became containers, due to its self-containement, isolation and ability to run absolutely anywhere \cite{7093032}. Container Orchestration make deployment and maintenance much easier thanks to automatization - examples: Kubernetes\cite{KUBERNETES}, Nomad\cite{NOMAD}. It takes care of whole lifecycle of the application and even auto-scaling. Unfortunately, managing those tools is a big challenge on its own, but thankfully nowadays we can get fully managed orchestrators `as a Service', so we can fully focus on building our system and not on infrastructure.

% TODO more deep into example technology stack - maybe later in comparison chapter

% Distributed transactions
Distributed transactions have the same processing requirements as regular database transactions, but they must be managed across multiple resources, making them more challenging to implement. When ACID transactions are required, the 2PC \cite{2PC_PATTERN} (two-phase commit) architecture with central transaction coordinator is a one solution. On the other, hand if eventual consistency is enough, there is SAGA pattern \cite{SAGA_PATTERN}, which works sequentially.

% language and technology agnostic
Language and technology-agnostic is another advantage presented around Microservices. A personally perceive it as negative for small teams, where few developers manages dozens of Microservices and they would have to constantly switch context. But it is great trait for large teams, where ideally one team has just one or couple of microservices. It gives a lot of freedom and developers like to play with every new shining piece of software/technology, which can result (if unchecked) in technology jungle to which no one understands and is unable to maintain. The same applies for languages. Although I am strong advocate for always using language for the right task, it must be well argued and everyone on the team should be familiar with it, because in small teams there is usually shared code ownership.


\subsection{Not the proclaimed silver bullet}
Over the last decade, microservices architecture has become so popular that very few people question whether it is the right architecture for the project at hand, and whether there might be something better for the job. One reason for this may be the incredible flood of articles on the web, with primers focusing on the positive aspects of microservices and how they can solve (almost) every problem, while not talking much about the possible negative aspects. It is important to note that most of the articles and success stories actually come from large companies with enormous resources (e.g. Netflix, Amazon, Coca-Cola) that none of the small/medium companies can match, while these smaller companies also face completely different challenges than the multinationals.

Microservices are very closely related to the modern concept of cloud computing, which has become a multi-billion market (\$545 billion in 2022\cite{CC_MARKET_SIZE}) with the potential to bring huge savings, but also huge expenses if not used properly. And let's not pretend that these cloud service providers are not, of course, trying to convince us to convert our infrastructure and systems to new modern technologies in order to increase their profits. This is nothing new, as everyone is just trying to make money, but we should be aware of their intentions when they try to convince us to use their technologies - which in the case of microservices and their complexity of operation and deployment will inevitably force us to use their services, but with monoliths we are usually capable of running everything ourselves.

To present some concrete data, let's look at some real-world examples where microservices were not considered to be the right solution.

\begin{example}[Amazon Prime]
    An example where microservices proved to be too costly a choice, and the entire application had to be migrated to a monolithic architecture for the system to be efficient, comes from Amazon. On 22 March (2023), Amazon's video streaming service called Prime Video published an article on their technology blog with the headline "Scaling the Prime Video audio/video monitoring service and reducing costs by 90\%". Prime Video offers thousands of live streams to its customers. To ensure that customers receive content seamlessly, Prime Video set up a tool to monitor every stream that customers watched to identify any perceived quality issues. \cite{AMAZON_ARTICLE}

    The initial version of the service consisted of distributed components orchestrated by \textit{AWS Step Functions}. This would allow each component to scale independently. However, the way they used the components meant that they hit a hard scaling limit at around 5\,\% of the expected load. Also, the total cost of all the components was too high to use on a large scale. The two most costly operations were the orchestration workflow and passing data between distributed components. To address this, they moved all the components into a single process to keep the data transfer within the process memory, which also simplified the orchestration logic. With all operations now consolidated into a single process, they were able to rely on scalable Amazon compute (EC2) and container (ECS) instances for deployment. \cite{AMAZON_ARTICLE}

    Conceptually, the high-level architecture remains the same. They still have exactly the same components as in the original design (media conversion, detectors, orchestration). This allowed them to reuse a lot of code and migrate quickly. Originally, they could scale multiple detectors horizontally because each one ran as a separate microservice. However, in the new approach, the number of detectors could only scale vertically, as they all ran within the same instance, and this would quickly exceed the capacity of a single instance. This limitation was overcome by running multiple instances and implementing a lightweight orchestration layer to distribute customer requests. Overall, the migration from a distributed microservices architecture to a monolithic one enabled them to reduce infrastructure costs by over 90\,\% and increase scalability. \cite{AMAZON_ARTICLE}
\end{example}

\begin{example}[Shopify]
    An example of a company that still successfully operates a monolithic system with thousands of developers is Shopify. It is a complete commerce platform that allows businesses to build an online store, market to customers and accept payments. The article\cite{SHOPIFY_MONOLITH_ARTICLE} with the most insight into their architecture is from 16 Sep 2020, and they regularly write more insight stories about their Monolith on their \textit{Shopify Engineering}\cite{SHOPIFY_ENGINEERING} website.

    They have a massive monolith written in the Ruby on Rails framework, its core alone has over 2.8 million lines of Ruby code. This is one of the oldest and largest Rails codebases on the planet and has been in continuous development since at least 2006. Rails doesn't provide patterns or tools for managing the inherent complexity and adding features in a structured, well-bounded way. That's why, in 2017, Shopify set up a team to investigate how to make its Rails monoliths more modular. The aim was to make it easier for them to scale to ever-increasing system capabilities and complexity by creating smaller, independent units of code, which they called components. The added constraints on how they wrote code triggered deep software design discussions across the organisation. This led to a shift in the mindset of developers towards a greater focus on modular design. Clearly defined ownership of parts of the code base was a key factor in the successful transition. \cite{SHOPIFY_MONOLITH_ARTICLE}

    The initial focus was on building a clean public interface around each component to hide the internals. The expectation was that changing the internals of one component wouldn't break other components, and it would be easier to understand the behaviour of a component in isolation. They had to balance the encapsulation with the dependency graph to avoid circular dependencies, which are very risky because changing any component in the chain can break all the other components. Various techniques such as control inversion and publish/subscribe mechanisms were introduced to help minimise relationships and reduce coupling. In the end they ended up with 37 components in the main monolith, and they are very deliberate about splitting functionality into separate services due to the overall complexity of a distributed system of services. \cite{SHOPIFY_MONOLITH_ARTICLE}
\end{example}

\begin{note*}
    Netflix is one of the most cited companies for its microservices architecture. What is not so well known is that the actual migration from monolithic system, when they started to have problems with performance and scaling, was in 2009. At that point they had been using Monolith for 10 years and had over 11~million \cite{NETFLIX_2009_EARNINGS} paying subscribers by that time. No one knows what would happen if they started the original architecture with something else, maybe it would work, but definitely the Monolith worked well until it just didn't fit their needs anymore.
\end{note*}